#!/bin/env perl

my $versnum = "1.3";

## DEVELOPMENT ONLY:
## use diagnostics;            # force verbose warning diagnostics
## use strict;                 # restrict unsafe constructs

use Getopt::Long;           # GetOptions
use File::Basename;         # fileparse, basename, dirname
use File::stat;             # ->mtime
use Pod::Usage;             # pod2usage



# ---------------------------------------------------------------------------
#   Defaults
#
# ---------------------------------------------------------------------------

my $all_commands = 0;
my $tcl_commands = 0;
my $gui_commands = 0;
my $comments = 0;
my $outfile = "synopsys.vim";
my @man_paths = ();
my @tool_list = ();

my $run_date = localtime();
my $run_args = "$0 @ARGV";

my %snps_tools = (
        "dc_shell" => 0,    # New default is OFF
        "icc_shell" => 0,
        "pt_shell" => 0,
        "fm_shell" => 0,
);


# ---------------------------------------------------------------------------
#   Process command-line options
#
# ---------------------------------------------------------------------------

my $show_help = 0;
my $show_usage = 0;
my $verbose = 0;
my $versinfo = 0;
my $vershow = 0;

GetOptions( 'all'               => \$all_commands,
            'comments!'         => \$comments,
            'gui!'              => \$gui_commands,
            'help|?'            => \$show_help,
            'manpath=s'         => \@man_paths,
            'output=s'          => \$outfile,
            'tcl!'              => \$tcl_commands,
            'tool=s'            => \@tool_list,
            'usage'             => \$show_usage,
            'verbose+'          => \$verbose,
            'V'                 => \$vershow,
            'version'           => \$versinfo ) or pod2usage(2);

# Output response to -V or --version.
print "$versnum\n" and exit 0 if $vershow;
print "$0, Version $versnum (" . scalar(localtime(stat($0)->mtime)) . ")\n"
        and exit 0 if $versinfo;

# Output embedded podtext for --help or --usage.
pod2usage(-verbose => 2) if ($show_help || $show_usage && $verbose);
pod2usage(-verbose => 0) if $show_usage;

# When no --tools given use "dc", "fm", and "pt".
if (!@tool_list && !@man_paths) {
    @tool_list = ( "dc", "fm", "pt" );
}

# Compose the executable names from the tool ids: dc -> dc_shell.
foreach my $id ( @tool_list ) {
    print "Enabling tool: ${id}_shell\n" if $verbose;
    $snps_tools{"${id}_shell"} = 1;
}
undef $tool_list;

# When --all commands, use all commands.
$tcl_commands = $gui_commands = 1 if $all_commands;


# ---------------------------------------------------------------------------
#   Find the man pages
#
# ---------------------------------------------------------------------------

print "Searching for man paths: " if $verbose;
print "\n" if $verbose > 1;

TOOL:
# foreach tool ( "dc_shell" "fm_shell" "pt_shell" )
foreach my $tool ( keys(%snps_tools) ) {

    # Ignore disabled tools.
    next TOOL unless $snps_tools{"$tool"};

    # Get the path to the tool's executable file, e.g.
    # path = "/var/tools/synopsys/dc-2015.06-SP1/bin/dc_shell"
    my $path = qx/which $tool/;
    chomp $path;

    # If which failed, path would be "dc_shell: Command not found."
    die "Executable for $tool not found\n" unless -x $path;

    # Find the (glob pattern) paths to the man pages, e.g.
    # path = "/var/tools/synopsys/dc-2015.06-SP1/doc/*/man"
    $path =~ s|bin/$tool|doc/*/man|;

    MAN:
    # foreach dir ( ".../doc/{icc,snps_gui,snps_tcl,syn}/man" )
    foreach my $dir ( glob("$path") ) {

        # Optionally ignore the snps_gui/man pages as,
        # ... well, who uses the GUI anyway?
        unless ($gui_commands) {
            if ($dir =~ m/snps_gui/) {
                print "# $dir (IGNORED)\n" if $verbose > 1;
                next MAN;
            }
        }

        push (@man_paths, $dir);
        print "- $dir\n" if $verbose > 1;
    }
}

print scalar(@man_paths) . "\n" if $verbose == 1;
print "Number of paths: " . scalar(@man_paths) . "\n" if $verbose > 1;

die "No man paths found\n" if (!@man_paths);


# ---------------------------------------------------------------------------
#   Collect Tcl command names to ignore
#
# ---------------------------------------------------------------------------

# These are command names that we shall ignore, i.e. standard Tcl commands
# which should be handled by the appropriate tcl.vim syntax file.
my %ignore_command = (
        "SEQGEN" => 1,
        "change_selection" => !$gui_commands,
        "change_selection_no_core" => !$gui_commands,
        "change_selection_too_many_objects" => !$gui_commands,
        "collections" => 1,
        "get_design" => 1,
        "get_generated_clock" => 1,
        "get_lib" => 1,
        "get_lib_cell" => 1,
        "get_lib_pin" => 1,
        "get_net" => 1,
        "get_path_group" => 1,
        "get_pin" => 1,
        "get_port" => 1,
        "get_selection" => !$gui_commands,
        "packagens" => 1,
        "pkMkIndex" => 1,
);

# Don't ignore the gui commands if requested.
foreach my $name ( keys(%ignore_command) ) {
    delete $ignore_command{"$name"} unless $ignore_command{"$name"};
}

unless ($tcl_commands) {

    print "Seaching for Tcl commands to igonore: " if $verbose;
    print "\n" if $verbose > 1;

    my $ignore_count = 0;

    # Get the path for the Tcl shell.
    my $path = qx/which tclsh/;
    chomp $path;

    die "tclsh not found\n" unless -x $path;

    # Fins the path to the man pages.
    $path =~ s|/bin/tclsh||;
    foreach my $dir ( glob("$path/man $path/share/man") ) {
        foreach my $file ( glob("$dir/mann/*.n $dir/mann/*.n.gz") ) {

            # Get the command name from the file name.
            my $name = basename($file, (".n", ".n.gz"));

            # Add the name to the list of ignored commands.
            $ignore_command{"$name"} = 1;
            $ignore_count++;
            print "- $name\n" if $verbose > 1;
        }
    }

    print $ignore_count . "\n" if $verbose == 1;
    print "Number of new ignored commands: " . $ignore_count . "\n" if $verbose > 1;

    die "tclsh man pages not found; try 'man -w n file' to detect the mann path\n" unless $ignore_count;
}


# ---------------------------------------------------------------------------
#   Collect the command names
#
# ---------------------------------------------------------------------------

print "Searching for commands: " if $verbose;
print "\n" if $verbose > 1;

my %man_files = ();

# Within all the man directories...
foreach my $dir ( @man_paths ) {

    # Look up the .../man/cat2/* files.
    PAGE:
    foreach my $file ( glob("$dir/cat2/*.2") ) {

        # Get the command name from the file name.
        # name = "write_file"
        my $name = basename($file, ".2");

        unless ($all_commands) {
            # Ignore selected commands or known aliases.
            if (defined($ignore_command{"$name"})) {
                print "# $name (IGNORED)\n" if $verbose > 1;
                next PAGE;
            }

            # Optionally, ignore GUI-related commands.
            if (!$gui_commands && $name =~ m/^(gui|win)_/) {
                print "# $name (IGNORED)\n" if $verbose > 1;
                next PAGE;
            }
        }

        # Store in a hash table: command name => colon-separated file names
        # e.g man_files{"write_file"} = "path1/write_file.2:path2/write_file.2"
        if (defined($man_files{"$name"})) {
            $man_files{"$name"} .= ":$file";
        } else {
            $man_files{"$name"} = "$file";
            print "- $name\n" if $verbose > 1;
        }
    }
}

print scalar(keys(%man_files)) . "\n" if $verbose == 1;
print "Number of man_files: " . scalar(keys(%man_files)) . "\n" if $verbose > 1;

die "No commands found\n" if (!keys(%man_files));


# ---------------------------------------------------------------------------
#   Reading the Manuals
#
# ---------------------------------------------------------------------------

print "Parsing man pages:\n" if $verbose;

my @simple_commands = ();
my %commands_with_args = ();

PARSE:
# foreach name ( "read_verilog" "write_file" ... )
foreach my $name ( sort(keys(%man_files)) ) {

    print "+ $name\n" if $verbose;

    my %options0 = ();
    my %options1 = ();
    my $opt_count = 0;

    # A command may have multiple man pages for multiple tools.
    # foreach file ( "path1/write_file.2" "path2/write_file.2" )
    foreach my $file ( split(/:/, $man_files{"$name"}) ) {

        my $syntax = 0;
        my $synopsis = "";

        # Get the man page as a simple text file:
        LINE:
        foreach my $line ( split(/\n/, qx/nroff $file | col -b/) ) {

            # Wait for the line labelled "SYNTAX".
            if ($syntax) {

                # Stop at the next "SECTION HEADER".
                last LINE if $line =~ m/^[A-Z]+/;

                # Concatenate the command and options.
                $synopsis .= " $line";

            } elsif ($line =~ m/^SYNTAX/) {

                # Start the SYNTAX processing.
                $syntax++;
            }
        }

        $synopsis =~ s/\s\s+/ /g;       # remove unnecessary whitespace.

        # Detect the "-options with_arguments" or "-type { a | b }".
        while ($synopsis =~ s/(-\w+)\s(\{|\w+)//) {
            $options1{"$1"} = 1;
            $opt_count++;
        }

        # Detect the "-single_options".
        while ($synopsis =~ s/(-\w+)//) {
            $options0{"$1"} = 1;
            $opt_count++;
        }
    }

    if ($opt_count) {

        # To be able to detect commands with the same options, we compile them
        # into a coded string like "-name -type // -quiet -strict".
        my $opt_code = join(" ",sort(keys(%options1))) . " // " . join(" ",sort(keys(%options0)));

        # Detecting commands with idential arguments is achieved simply
        # by creating another hash table: opt_code => commands.
        if (defined($commands_with_args{"$opt_code"})) {
            $commands_with_args{"$opt_code"} .= " $name";
        } else {
            $commands_with_args{"$opt_code"} = $name;
        }

    } else {

        # No options for this command.
        push(@simple_commands, $name);
    }
}


# ---------------------------------------------------------------------------
#   Composing Syntax Commands
#
# ---------------------------------------------------------------------------

print "Generating syntax file: $outfile\n" if $verbose;

open(SYN, "> $outfile") or die "Can't open $outfile: $!, stopped";

print "- header\n" if $verbose;

print SYN <<HEADER;
" Vim syntax file
" Language      TCL/TK with Synopsys keywords
"
" Autogenerated $run_date
" by $run_args

set iskeyword=@,48-57,_,192-255,-

HEADER

# ---------------------------------------------------------------------------
# Commands without arguments
# ---------------------------------------------------------------------------

print "- simple commands\n" if $verbose;

foreach my $name ( sort(@simple_commands) ) {

    if ($comments) {
        # Preceed the syntax definition with a comment of the source files.
        foreach my $file ( split(/:/, $man_files{"$name"}) ) {
            print SYN "\" $file\n";
        }
    }

    # Simple commands have a single-line syntax declaration.
    print SYN "syn keyword snpsCmd $name\n";
}

print SYN "\n";

# ---------------------------------------------------------------------------
# Commands with arguments.
# ---------------------------------------------------------------------------

print "- commands with arguments\n" if $verbose;

my $code_count = 0;

foreach my $opt_code ( sort(keys(%commands_with_args)) ) {

    my $region = "snpsReg$code_count";
    my $group  = "snpsGrp$code_count";
    my $switch = "snpsSwt$code_count";

    my ($double_opts, $single_opts) = split(/ \/\/ /, $opt_code);

    if ($comments) {
        # Preceed the syntax definition with a comment of the source files.
        foreach my $name ( split(/ /,$commands_with_args{"$opt_code"}) ) {
            foreach my $file ( split(/:/, $man_files{"$name"}) ) {
                print SYN "\" $file\n";
            }
        }
    }

    # Complex commands require region declarations.
    print SYN "syn keyword snpsCmd contained " . $commands_with_args{"$opt_code"} . " skipwhite nextgroup=$region\n";
    print SYN "syn region $region contained excludenl keepend start=+.+ skip=+\\\\\$+ end=+\}\\|]\\|;\\|\$+ contains=$group,\@tclStuff\n";

    if ($single_opts ne "") {
        print SYN "syn match $group contained \"-\\a\\+\" contains=$switch\n";
        print SYN "syn keyword $switch contained $single_opts\n";
    }

    if ($double_opts ne "") {
        print SYN "syn match $group contained \"-\\a\\+\" contains=$switch\n";
        print SYN "syn keyword $switch contained $double_opts\n";
    }

    print SYN "\n";

    $code_count++;
}

print SYN "\n";

# ---------------------------------------------------------------------------
# Highlighting
# ---------------------------------------------------------------------------
print "- footer\n" if $verbose;

my $switch_count = 0;
while ($switch_count < $code_count) {
    my $switch = "snpsSwt$switch_count";
    print SYN "hi def link $switch tclOption\n";
    $switch_count++;
}

print SYN <<FOOTER;

hi def link snpsCmd         Statement
FOOTER

close(SYN);



# ---------------------------------------------------------------------------
#   Embedded Usage
#
# ---------------------------------------------------------------------------

__END__

=head1 NAME

snpsMan2VimSyntax - create vim syntax files from Synopsys man pages.

=head1 SYNOPSIS

snpsMan2VimSyntax [options]

    Options:
        -all                Do not hide known duplicate/GUI commands.
        -(no)comments       Adds man file page comments (default: off).
        -help|-?            Shows this help message.
        -manpath /p/man     Defines the path of the man directory.
        -output name.vim    Define the output file (default synopsys.vim).
        -tool id            Will enable handling "<id>_shell" commands.
        -usage              Shows just the synopsis of the help message.
        -verbose            Shows more progress or help messages.

=head1 OPTIONS

=over 8

=item B<-all> | B<-(no)tcl> | B<-(no)gui>

With the B<-all> option, syntax definitions are generated for all commands.
The default is to hide standard Tcl commands (B<-notcl>) and GUI commands
(B<-nogui>).

=item B<-(no)comments>

Can be used to enable or disable the generation of comments in the output
file. The default is off, i.e. B<-nocomments>. When on, each syntax
definition for a command will be preceeded with a comment that is listing
the man source files upon which the definition was based.

=item B<-help> | B<-?>

Shows the help message or with B<-verbose> the entire manual page.

=item B<-manpath>

Use can this option (when the standard approch via B<-tool> fails) to
specify the location of a F<man> path. For multiple paths, feel free to
use this option multiple times.

=item B<-output> file

Sets the name of the output file to generate. The default name is
"synopsys.vim".

=item B<-tool> id

Adds <id>_shell to the list of tools to search. You can use this option
multiple times for multiple tools, see example below. Defaults to C<dc>,
C<fm>, and C<pt> (unless B<-manpath> was used).

=item B<-usage>

Shows the usage information for this command, i.e. the just the SYNOPSIS
section.

=item B<-verbose>

Shows progress messages or additional help texts. Even more progress and
debug messsages are produced if you use this option twice.

=item B<-V> | B<-version>

Shows the version number or the verbose version information for
this script.

=back

=head1 DESCRIPTION

B<snpsMan2VimSyntax> parses the manual pages for synopsys tool commands and
generates VIM syntax files for the commands and their arguments.

For each tool <id>, it looks up the installation path for a <id>_shell,
and searches for the manual pages in the installation tree. Only man2
pages, i.e. tool-internal commands are scanned. Each of the commands is
parsed and a single VIM syntax definition file is generated.

The generated syntax file has two sections. In the first section,
simple commands (those without arguments) are listed as:

    syn keyword snpsCmd command17

In the second section we output syntax regions for commands with
arguments:

    syn keyword snpsCmd contained command42 skipwhite nextgroup=snpsReg42
    syn region snpsReg42 contained excludenl keepend start=+.+ skip=+\\$+ end=+}\|]\|;\|$+ contains=snpsGrp293,@tclStuff
    syn match snpsGrp42 contained "-\a\+" contains=snpsSw42
    syn keyword snpsSwt42 contained -verbose
    syn match snpsGrp42 contained "-\a\+" contains=snpsSwt42
    syn keyword snpsSwt42 contained -output

The color options assigned to the commands and options are:

    hi def link snpsSwt42 tclOption
    hi def link snpsCmd Statement

NB. C<tclOption> and C<tclStuff> are defined in the default F<tcl.vim> syntax
definition for Tcl (which should be loaded first before loading synopsys.vim).


=head1 INSTALL

Vim usually comes with F<tcl.vim> (1) pre-installed. If it were missing,
or if you wanted to use a different version, you can add it to your local
F<.vim> configuration directory:

    ~/.vim/syntax/tcl.vim (2)

To install the generated syntax file, place it here:

    ~/.vim/syntax/synopsys.tcl (S)

Next add an additional F<tcl.vim> that is read I<after> the standard Tcl
syntax file:

    ~/.vim/after/syntax/tcl.vim (A)

Within that file, you can define your own syntax definitions. Add the
following line to include the F<synopsys.vim> file:

    " Add the synopsys.vim file to the Tcl syntax.
    source ~/.vim/syntax/synopsys.vim

Done.

From now on, whenever you edit a Tcl source file in Vim with C<syntax=tcl>
and C<syntax on>, Vim will read (1) or if present (2), then (A) which loads
(S).


=head1 EXAMPLE

snpsMan2VimSyntax -tool dc -tool icc -comments -out implementation.vim -verbose

=head1 REQUIREMENTS

Obviously, the corresponding Synopsys tools need to be installed to be able
to access their manual pages. B<nroff> is used to parse the pages, B<col> to
ignore escaped colour codes. To be able to ignore standard Tcl commands, a
stand-alone version of Tcl needs to be installed (the script searches for
B<tclsh>).


=head1 SEE ALSO

L<Vim.org|http://www.vim.org/>
L<Vim.org/scripts|http://www.vim.org/scripts/script_search_results.php?keywords=tcl&script_type=syntax&order_by=downloads&direction=descending&search=search>

=head1 AUTHOR

Eric Roller

=cut
